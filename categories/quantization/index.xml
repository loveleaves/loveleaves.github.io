<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Quantization on 安哲睿</title>
        <link>https://loveleaves.github.io/categories/quantization/</link>
        <description>Recent content in Quantization on 安哲睿</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Andrew Stark</copyright>
        <lastBuildDate>Wed, 19 Feb 2025 00:00:10 +0800</lastBuildDate><atom:link href="https://loveleaves.github.io/categories/quantization/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>【量化】 神经网络量化介绍</title>
        <link>https://loveleaves.github.io/p/quantization/</link>
        <pubDate>Mon, 10 Feb 2025 00:00:00 +0000</pubDate>
        
        <guid>https://loveleaves.github.io/p/quantization/</guid>
        <description>&lt;h2 id=&#34;references&#34;&gt;References
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/58182172&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Int8量化-介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Ewenwan/MVision/tree/master/CNN/Deep_Compression/quantization&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;量化方法汇总&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/387072703&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;从TensorRT与ncnn看CNN卷积神经网络int8量化算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;谷歌量化白皮书：&lt;a class=&#34;link&#34; href=&#34;https://arxiv.org/pdf/1806.08342&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Quantizing deep convolutional networks for efficient inference: A whitepaper&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://arxiv.org/pdf/1712.05877&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Quantization and Training of Neural Networks for Efficient Integer-Arithmetic-Only Inference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/OpenPPL/ppq&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ppq&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1gS4y1Y7KR/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;神经网络 - 量化与部署&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/355598250&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;模型压缩：模型量化打怪升级之路 - 1 工具篇&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;神经网络加速基础知识&#34;&gt;神经网络加速基础知识
&lt;/h2&gt;&lt;h3 id=&#34;计算机体系结构组成原理&#34;&gt;计算机体系结构/组成原理
&lt;/h3&gt;&lt;p&gt;主要了解以下部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://foxsen.github.io/archbase/sec-ISA.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;指令系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://foxsen.github.io/archbase/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%92%8C%E7%BB%93%E6%9E%84.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;计算机组成原理和结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/CorePower/p/CorePower.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;流水线技术&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指令耗时热点指令&#34;&gt;指令耗时/热点指令
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;现代处理器&#34;&gt;现代处理器
&lt;/h3&gt;&lt;h4 id=&#34;经典cpu体系结构&#34;&gt;经典CPU体系结构
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;x86架构cisc&#34;&gt;x86架构（CISC）
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;胶水typo，多核心&lt;/li&gt;
&lt;li&gt;部分组件公共化，提高集成度
&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_3.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;gpu架构&#34;&gt;GPU架构
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;共享指令译码和控制，ALU运行的指令相同（分支发散问题）&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://loveleaves.github.io/p/gpu&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GPU架构介绍&lt;/a&gt;
&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_4.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;asic专用芯片架构&#34;&gt;ASIC专用芯片架构
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;继续移除非必要指令（浮点、图形支持等）&lt;/li&gt;
&lt;li&gt;特定领域设计&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;异构计算与主从设备交互&#34;&gt;异构计算与主从设备交互
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_5.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;找到性能瓶颈performance-bottleneck&#34;&gt;找到性能瓶颈（performance bottleneck）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;高算力场景=》用ASIC等芯片，提高算力，高延迟&lt;/li&gt;
&lt;li&gt;低延迟场景=》用FPGA等芯片，降低延迟，低算力&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;性能热点分析工具&#34;&gt;性能热点分析工具
&lt;/h2&gt;&lt;h3 id=&#34;torch-profiler&#34;&gt;torch Profiler
&lt;/h3&gt;&lt;h3 id=&#34;nsight-compute&#34;&gt;Nsight Compute
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://loveleaves.github.io/p/tool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Nsight Compute&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;量化硬件实现&#34;&gt;量化硬件实现
&lt;/h2&gt;&lt;h3 id=&#34;量化算子&#34;&gt;量化算子
&lt;/h3&gt;&lt;p&gt;基本公式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;float value = 1.0; // 输入值
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;float scale = 0.1; // 用于缩放输入值（尺度因子）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int32 qt_32 = round_fn(value/scale); // 取整
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int8 qt_8 = clip(qt_32, Q_MIN, Q_MAX); // 范围截断
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;取整函数&lt;code&gt;round_fn&lt;/code&gt;比较特别，在不同硬件上有不同的&lt;strong&gt;取整模式&lt;/strong&gt;（主要对中间值，如1.5，-2.5等），常见取整模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Round half to even，torch 、 C使用，向偶数方向取整&lt;/li&gt;
&lt;li&gt;Round half away from zero，向正负无穷方向取整&lt;/li&gt;
&lt;li&gt;Round half toward zero，向0方向取整&lt;/li&gt;
&lt;li&gt;Round half down，向下取整&lt;/li&gt;
&lt;li&gt;Round half up，向上取整&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;量化子图与全精度子图quantized-subgraph&#34;&gt;量化子图与全精度子图（quantized subgraph）
&lt;/h3&gt;&lt;p&gt;权重是可以直接计算出来的，推理的时候只要计算一下量化算子即可&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通常情况，量化算子全部支持场景：
&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_6.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存在不支持量化算子，可用&lt;code&gt;子图分割&lt;/code&gt;分离不支持运算子图分开计算，但会导致访存开销为热点
&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_7.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;反量化算子&#34;&gt;反量化算子
&lt;/h3&gt;&lt;p&gt;基本公式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Char value = 1; // 量化算子/运算输出值
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;float scale = 0.1; // 用于缩放输入值（尺度因子）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Float deq = (value * scale);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;量化模式量化与反量化&#34;&gt;量化模式（量化与反量化）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;对称量化：基本量化模式，分布对称&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int32 qt_32 = round_fn(value/scale); // 取整
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int8 qt_8 = clip(qt_32, Q_MIN, Q_MAX); // 范围截断
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 反量化对应量化反向操作，类似encode《=》decode
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;非对称量化：充分利用int8数值范围（如relu负数范围）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int32 qt_32 = round_fn(value/scale) + offset; // 取整
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;uint8 qt_8 = clip(qt_32, Q_MIN, Q_MAX); // 范围截断
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;整数量化（power of two）：部分硬件不支持浮点运算，用整数运算替换&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int32 qt_32 = round_fn(value * (2 &amp;lt;&amp;lt; shift)); // 取整，shift-定点位
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int8 qt_8 = clip(qt_32, Q_MIN, Q_MAX); // 范围截断
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;指数量化&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tensor量化与通道量化&#34;&gt;tensor量化与通道量化
&lt;/h3&gt;&lt;p&gt;以上对称/非对称量化、整数量化中的offset、shift可以整个数据为粒度进行量化（可能数值偏差大，量化差），也可以采用其他粒度进行量化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tensor量化（per-tensor）：以单个tensor为粒度&lt;/li&gt;
&lt;li&gt;通道量化（per-channel）：以单个channel为粒度&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;量化计算怎么写&#34;&gt;量化计算怎么写
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;整数运算：在许多硬件上，整数运算的微指令条数和指令吞吐量等可能和浮点差不多甚至比浮点差&lt;/li&gt;
&lt;li&gt;访存：量化后数据传输耗时少&lt;/li&gt;
&lt;li&gt;向量化技术：SIMD/SIMT，&lt;a class=&#34;link&#34; href=&#34;https://godbolt.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;代码向量化网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;量化计算一般是：量化+反量化，目的是为了保证量化计算的逻辑与原来一致&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;量化乘法quantized-mul&#34;&gt;量化乘法（quantized mul）
&lt;/h3&gt;&lt;p&gt;正常int8计算会溢出，所以先反量化成float计算乘法再量化，即量化计算一般要加上rescale操作&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 原本量化运算
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ouput[i][j]=inputa[i][j]*inputb[i][j]; //in/out均为int8
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 如果采用对称量化
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ouput[i][j]=clip(round_fn(inputa[i][j]*scale_a * inputb[i][j] * scale_b / scale_c)); // scale 为float
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;即 ouput[i][j]=quantizied(inputa[i][j] * inputb[i][j] / scale_abc); // scale_abc 可提前算
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 同理，如果采用整数量化
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;即 ouput[i][j]=quantizied(inputa[i][j] * inputb[i][j] &amp;lt;&amp;lt; round(log2 scale_abc)); // scale_abc 可提前算
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;量化加法&#34;&gt;量化加法
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;加法要求两个操作数的scale必须一致&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 原本量化运算
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ouput[i][j]=inputa[i][j]+inputb[i][j]; //in/out均为int8
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 如果采用对称量化
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ouput[i][j]=clip(round_fn((inputa[i][j]*scale_a + inputb[i][j] * scale_b) / scale_c)); // scale 为float
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 这里加法要求scale_a和scale_b必须一致（两个操作数的scale）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;即 ouput[i][j]=quantizied((inputa[i][j] + inputb[i][j]) / scale_ab); // scale_ab 可提前算
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;量化激活函数&#34;&gt;量化激活函数
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;要求输入输出的scale必须一致&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 原本clip量化运算
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ouput[i][j]=max(inputa[i][j], min); //in/out均为int8
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 如果采用对称量化
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ouput[i][j]=clip(round_fn((inputa[i][j]*scale_in + min) / scale_out)); // scale 为float
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 这里加法要求scale_in和scale_out必须一致
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;即 ouput[i][j]=inputa[i][j] + min / scale_in; // 注意这里没有round_fn、clip操作，min被动量化
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 这时这类算子被称为被动量化算子，如clip、relu、concat等
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;量化矩阵乘quantized-gemm&#34;&gt;量化矩阵乘（quantized Gemm）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;int8输入=》int16/32计算乘法=》int32/64保存求和结果=》量化为int8输出&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;量化非线性运算&#34;&gt;量化非线性运算
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;算子包含非线性运算。如：exp、tanh、sigmoid、softmax等&lt;/li&gt;
&lt;li&gt;非线性运算：用int无法替代float计算求得结果&lt;/li&gt;
&lt;li&gt;CPU、GPU上，不做量化，以全精度模式运行&lt;/li&gt;
&lt;li&gt;FPGA、ASIC、DSP上，不支持浮点运算，需要更改算子计算逻辑，以线性运算拟合或直接查表&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;计算图&#34;&gt;计算图
&lt;/h2&gt;&lt;h3 id=&#34;算子&#34;&gt;算子
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;常见算子：https://github.com/onnx/onnx/blob/main/docs/Operators.md&lt;/li&gt;
&lt;li&gt;最小调度单位&lt;/li&gt;
&lt;li&gt;算子融合加速：减少访存调用栈开销，优化计算逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常见计算图优化算子融合&#34;&gt;常见计算图优化（算子融合）
&lt;/h3&gt;&lt;p&gt;计算图优化实践：https://www.bilibili.com/video/BV1Kr4y1n7cy/&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;激活函数融合：Computing Op -&amp;gt; Activation =&amp;gt; ConputAct
&lt;ul&gt;
&lt;li&gt;常见OP：Conv、ConvTranpose、Gemm&lt;/li&gt;
&lt;li&gt;常见Act：Relu、Clip（relu6）、Prelu、Tanh、Sigmoid、Switsh&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;移除batchnorm和dropout&lt;/li&gt;
&lt;li&gt;常量折叠：把常量融合进行计算&lt;/li&gt;
&lt;li&gt;矩阵乘融合&lt;/li&gt;
&lt;li&gt;conv-add融合：Conv + any =&amp;gt; Y = Wx + (Y2 + B)
&lt;ul&gt;
&lt;li&gt;Conv：Y1=WX+B&lt;/li&gt;
&lt;li&gt;any：Y2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;联合定点&#34;&gt;联合定点
&lt;/h3&gt;&lt;p&gt;用于支持多后端使用，保留原始计算图信息和量化后的计算图信息&lt;/p&gt;
&lt;h2 id=&#34;图调度graph-dispatching&#34;&gt;图调度（Graph Dispatching）
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;误差分析后发现部分算子的误差较大，可将其单独调度到非量化平台计算&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;图模式匹配&#34;&gt;图模式匹配
&lt;/h3&gt;&lt;p&gt;一个计算图可以表示为一个由节点、边集、输入边、输出边组成的四元组 C = {N, E, I, O}。&lt;/p&gt;
&lt;p&gt;我们往往需要在计算图中寻找&lt;strong&gt;指定结构&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何用一个严谨的方式定义&lt;strong&gt;结构&lt;/strong&gt;？&lt;/li&gt;
&lt;li&gt;如何设计计算模式匹配法，使得其尽可能高效？&lt;/li&gt;
&lt;li&gt;图模式匹配是&lt;strong&gt;量化算法、算子融合、算子调度&lt;/strong&gt;的基础。&lt;/li&gt;
&lt;li&gt;图模式匹配可用方法：子图匹配、遍历模式匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;例子&#34;&gt;例子
&lt;/h4&gt;&lt;p&gt;想象一个场景，onnx不支持swish算子，其可能用以下算子组合实现：
&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_8.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
这样有一个问题，量化时会将这三个算子都量化一遍，但其实只需要量化最后一个mul算子即可。这里就可以利用图模式匹配匹配到这个替代的swish结构，并针对性进行处理。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 匹配swish，子图模式匹配
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;search_engine = SearchableGraph(graph)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;results = search_engine.pattern_matching(
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    patterns = lambda x: x.is_computing_op(&amp;#39;Sigmoid&amp;#39;, &amp;#39;Mul&amp;#39;),
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    edges = [[0, 1], [1, 2], [0, 2]],
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    exclusive = True
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;for computing_op, sigmoid, mul in results:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;遍历模式匹配&#34;&gt;遍历模式匹配
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;匹配模式：起点表达式=》中继点..=》终点..，自动机&lt;/li&gt;
&lt;li&gt;步骤：图拆成树，树拆成链，在每个链上进行模式匹配，期间可用动态规划优化&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;子图模式匹配&#34;&gt;子图模式匹配
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;子图同构问题为NP-Hard问题，使用近似算法&lt;/li&gt;
&lt;li&gt;避免模式pattern多义性，保持互斥&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;算子调度&#34;&gt;算子调度
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;SOI正向传播：从开始算子往后找，可能有多个匹配&lt;/li&gt;
&lt;li&gt;正向传播的反方向，从终点算子开始往前找&lt;/li&gt;
&lt;li&gt;调度争议区：既可以量化，又不可以量化&lt;/li&gt;
&lt;li&gt;调度约束：
&lt;ul&gt;
&lt;li&gt;激活函数与计算节点保持同一平台&lt;/li&gt;
&lt;li&gt;NMS、shape、TOPK、MAX与计算节点保持同一平台&lt;/li&gt;
&lt;li&gt;参与图融合的算子保持同一平台&lt;/li&gt;
&lt;li&gt;孤立计算节点不量化&lt;/li&gt;
&lt;li&gt;多输入算子所有输入同平台&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;手动调度：权衡精度和速度，考虑硬件支持情况&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;神经网络部署&#34;&gt;神经网络部署
&lt;/h2&gt;&lt;h3 id=&#34;运行时runtime&#34;&gt;运行时（runtime）
&lt;/h3&gt;&lt;p&gt;实际硬件执行库，针对不同硬件有不同实现&lt;/p&gt;
&lt;h3 id=&#34;神经网络部署-1&#34;&gt;神经网络部署
&lt;/h3&gt;&lt;p&gt;各厂商的训练框架、推理框架、硬件厂商
&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_9.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部署流程&lt;/strong&gt;：训练框架训练模型=》导出统一中间表达模型（可选）=》指定推理框架=》指定硬件执行
&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_10.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部署建议&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保你的网络可以被Onnx表示，避免其中出现复杂条件逻辑及循环逻辑。&lt;/li&gt;
&lt;li&gt;学会自定义算子，以备不时之需，（包括自定义算子的推理实现）。&lt;/li&gt;
&lt;li&gt;避免使用各种小Trick，额外加入的算子很可能会破坏图优化。&lt;/li&gt;
&lt;li&gt;神经网络能跑多快是Runtime决定的，神经网络加速应当根据runtime进行。&lt;/li&gt;
&lt;li&gt;用一下 Onnx Simplifier。&lt;/li&gt;
&lt;li&gt;写一个固定的 batchsize大小（latency和吞吐）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;onnx部署推理&#34;&gt;ONNX部署推理
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://onnxruntime.ai/docs/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;onnxruntime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tensorrt&#34;&gt;TensorRT
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://developer.nvidia.com/tensorrt&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Develop Guide&lt;/a&gt;, &lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/deeplearning/tensorrt/latest/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;docs&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/deeplearning/tensorrt/latest/inference-library/work-quantized-types.html#introduction-to-quantization&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;quantization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;连贯量化区：不要在网络中过度使用不可量化算子&lt;/li&gt;
&lt;li&gt;网络结构设计、量化点插入不能破坏图融合&lt;/li&gt;
&lt;li&gt;Tensor对齐&lt;/li&gt;
&lt;li&gt;Profiler工具分析：Nsight System&lt;/li&gt;
&lt;li&gt;自定义算子，必要时自己写plugin：https://github.com/NVIDIA/TensorRT/tree/release/10.8/plugin&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;量化理论分析&#34;&gt;量化理论分析
&lt;/h2&gt;&lt;h3 id=&#34;量化参数选择&#34;&gt;量化参数选择
&lt;/h3&gt;&lt;p&gt;假设
&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_11.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ln/s用比值来评估量化偏差，忽略实际值的大小&lt;/li&gt;
&lt;li&gt;int8实际应为-128，这里为了对称写成-127&lt;/li&gt;
&lt;li&gt;注意这里的截断边界条件为.5，如127.5，-127.5，为了尽可能保留原精度&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;最大值截断&#34;&gt;最大值截断
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_12.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_13.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;也就是说最大值截断在元素值趋于无限时，会出现误差发散的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;分位数截断&#34;&gt;分位数截断
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_14.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实际运用时，结合&lt;code&gt;3-sigma&lt;/code&gt;原则取近似&lt;code&gt;sigma&lt;/code&gt;值&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;最优截断&#34;&gt;最优截断
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_15.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bernard Widrow公式&lt;/strong&gt;
&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_16.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
最优估计问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最优截断要求pdf的三阶积分，并求导令上式为0，对于大部分分布而言，无法顺利求得解析解。&lt;/li&gt;
&lt;li&gt;同时在很多情况下，局部的MSE最优并不是全局MSE最优的。&lt;/li&gt;
&lt;li&gt;数据量小时，估计的方差很大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;枚举最优截断&#34;&gt;枚举最优截断
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_17.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_18.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;梯度优化截断&#34;&gt;梯度优化截断
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_19.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;量化误差分析&#34;&gt;量化误差分析
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1V94y117Ej/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.bilibili.com/video/BV1V94y117Ej/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;量化框架&#34;&gt;量化框架
&lt;/h2&gt;&lt;h3 id=&#34;ppq&#34;&gt;PPQ
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://loveleaves.github.io/imgs/quantization_20.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1kt4y1b75m/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PPQ框架介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV128411v7us/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;大模型LLM推理加速&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tensorrt-1&#34;&gt;TensorRT
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/NVIDIA/TensorRT/tree/master/tools/pytorch-quantization&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;pytorch-quantization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ncnn&#34;&gt;NCNN
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/71881443&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;NCNN Conv量化详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>【GPU】 GPU架构及使用介绍</title>
        <link>https://loveleaves.github.io/p/gpu/</link>
        <pubDate>Fri, 03 Jan 2025 00:00:00 +0000</pubDate>
        
        <guid>https://loveleaves.github.io/p/gpu/</guid>
        <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍
&lt;/h2&gt;&lt;p&gt;CUDA（Compute Unified Device Architecture，统⼀计算架构）是由 NVIDIA 开发的并行计算平台和编程模型，旨在利用 NVIDIA GPU（图形处理单元）强大的并行计算能力来加速计算密集型任务。CUDA 提供了一种编程接口，让程序员能够直接访问 GPU 上的计算资源。通过并行化计算任务，可以显著提升执行效率。GPU 相较于 CPU，在处理大量并行任务时具有显著的优势，通常拥有成百上千的处理核心（CUDA 核心），能够同时执行大量的操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心指标：核心数、GPU显存容量、GPU计算峰值、显存带宽&lt;/li&gt;
&lt;li&gt;GPU不能单独计算，CPU+GPU组成异构计算架构：CPU起到控制作用，一般称为主机（Host）；GPU可以看作CPU的协处理器，一般称为设备（Device）；主机和设备之间内存访问一般通过PCIe总线链接。&lt;/li&gt;
&lt;li&gt;CUDA 提供两层API接口：CUDA驱动(driver)API和CUDA运行时(runtime)API&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;references&#34;&gt;References
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/SeventhBlue/cudaLearningMaterials_2/blob/master/CUDA%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-GPU%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97-%E9%AB%98%E6%B8%85%E6%89%AB%E6%8F%8F-%E4%B8%AD%E8%8B%B1%E6%96%87/CUDA%20Programming%20A%20Developer%27s%20Guide%20to%20Parallel%20Computing%20with%20GPUs.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《CUDA 并行程序设计-GPU 编程指南》&lt;/a&gt; 第5、6、9章&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/loveleaves/ML_CPP/tree/main/ParallelFramework/CUDA&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/loveleaves/ML_CPP/tree/main/ParallelFramework/CUDA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/cuda/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cuda docs&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;programming-guide&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;best-practices-guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://cis5650-fall-2024.github.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CIS 5650-GPU Programming and Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://staskaer.github.io/2022/09/05/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-2/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CUDA笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/NVIDIA/CUDALibrarySamples&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CUDALibrarySamples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cuda框架&#34;&gt;CUDA框架
&lt;/h2&gt;&lt;h3 id=&#34;基础编程框架&#34;&gt;基础编程框架
&lt;/h3&gt;&lt;p&gt;单文件example.cu编程框架&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;header&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inclusion&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;or&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;macro&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;definition&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;declarations&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;of&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;functions&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CUDA&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernels&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;allocate&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;host&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;device&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;memory&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;initialize&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;host&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;memory&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;transfer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;host&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;device&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;launch&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;calculations&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;the&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;device&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;transfer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;device&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;host&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;free&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;host&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;device&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;memory&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;definitions&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;of&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;functions&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CUDA&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernels&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;编译指令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;nvcc -arch=sm_XY -code=compute_XY -o example example.cu
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;nvcc编译工作原理&#34;&gt;nvcc编译工作原理
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/_images/cuda-compilation-from-cu-to-executable.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;CUDA Compilation Trajectory&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;host code（standard C/C++ compiler）、device code（compiled into PTX/cubin）&lt;/li&gt;
&lt;li&gt;CUDA程序兼容性考虑：在将源代码编译为 PTX 代码时，需要用选项-arch=compute_XY指定一个虚拟架构的计算能力，用以确定代码中能够使用的CUDA功能。在将PTX代码编译为cubin代码时，需要用选项-code=sm_ZW指定一个真实架构的计算能力，用以确定可执行文件能够使用的GPU。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.kapilsharma.dev/posts/deep-dive-into-triton-internals/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Deep Dive into Triton Internals&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gpu设备设置&#34;&gt;GPU设备设置
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;1、获取GPU设备数量&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int iDeviceCount = 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cudaGetDeviceCount(&amp;amp;iDeviceCount);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;2、设置GPU执行时使用的设备&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int iDev = 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cudaSetDevice(iDev)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;内存管理&#34;&gt;内存管理
&lt;/h3&gt;&lt;p&gt;主设内存管理
&lt;strong&gt;Note&lt;/strong&gt;：GPU内存管理runtime接口传入的是&lt;strong&gt;双重指针&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存分配：malloc、cudaMalloc&lt;/li&gt;
&lt;li&gt;数据传递：memcpy、cudaMemcpy&lt;/li&gt;
&lt;li&gt;内存初始化：memset、cudaMemset&lt;/li&gt;
&lt;li&gt;内存释放：free、cudaFree&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主设内存传递&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cudaError_t cudaMemcpy(dst, src, count, kind);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;枚举类型kind可取值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cudaMemcpyHostToHost，表示从主机复制到主机。&lt;/li&gt;
&lt;li&gt;cudaMemcpyHostToDevice，表示从主机复制到设备。&lt;/li&gt;
&lt;li&gt;cudaMemcpyDeviceToHost，表示从设备复制到主机。&lt;/li&gt;
&lt;li&gt;cudaMemcpyDeviceToDevice，表示从设备复制到设备。&lt;/li&gt;
&lt;li&gt;cudaMemcpyDefault，表示根据指针dst和src所指地址自动判断数据传输的方向。这要求系统具有统一虚拟寻址（unifiedvirtualaddressing）的功能（要求64位的主机）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据同步synchronize&#34;&gt;数据同步Synchronize
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;调用输出函数时，输出流是先存放在缓冲区的，而缓冲区不会自动刷新。只有程序遇到某种同步操作时缓冲区才会刷新。所以当要打印某个数据时，要先使用函数cudaDeviceSynchronize显式地同步主机与设备，促使缓冲区刷新。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;核函数kernel-function&#34;&gt;核函数（Kernel function）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;1、核函数&lt;strong&gt;在GPU上&lt;/strong&gt;进行&lt;strong&gt;并行执行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;2、注意：
&lt;ul&gt;
&lt;li&gt;（1）限定词__global__ 修饰（可在void前后）&lt;/li&gt;
&lt;li&gt;（2）返回值必须是void&lt;/li&gt;
&lt;li&gt;（3）对于N是非blockSize整数倍时，必要时添加if，即使导致条件分支&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、核函数只能访问GPU内存&lt;/li&gt;
&lt;li&gt;2、核函数不能使用变长参数&lt;/li&gt;
&lt;li&gt;3、核函数不能使用静态变量&lt;/li&gt;
&lt;li&gt;4、核函数不能使用函数指针&lt;/li&gt;
&lt;li&gt;5、核函数具有异步性&lt;/li&gt;
&lt;li&gt;6、其他：核函数不支持C++的iostream&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;自定义设备函数&#34;&gt;自定义设备函数
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;用__global__修饰的函数称为核函数，一般由主机调用，在设备中执行。如果使用动态并行，则也可以在核函数中调用自己或其他核函数。&lt;/li&gt;
&lt;li&gt;用__device__修饰的函数叫称为设备函数，只能被核函数或其他设备函数调用，在设备中执行。&lt;/li&gt;
&lt;li&gt;用__host__修饰的函数就是主机端的普通C++函数，在主机中被调用，在主机中执行。对于主机端的函数，该修饰符可省略。之所以提供这样一个修饰符，是因为有时可以用__host__和__device__同时修饰一个函数，使得该函数既是一个C++中的普通函数，又是一个设备函数。这样做可以减少冗余代码。编译器将针对主机和设备分别编译该函数。&lt;/li&gt;
&lt;li&gt;不能同时用__device__和__global__修饰一个函数，即不能将一个函数同时定义为设备函数和核函数。&lt;/li&gt;
&lt;li&gt;也不能同时用__host__和__global__修饰一个函数，即不能将一个函数同时定义为主机函数和核函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程模型&#34;&gt;线程模型
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;线程的组织结构是由执行配置（executionconfiguration）&amp;laquo;&amp;lt;grid_size,block_size&amp;raquo;&amp;gt;决定的。这里的grid_size（网格大小）和block_size（线程块大小），对应核函数内部的内建变量 gridDim、blockDim、blockIdx、threadIdx&lt;/li&gt;
&lt;li&gt;注意GPU系列对应框架最大允许的线程块大小，如1024&lt;/li&gt;
&lt;li&gt;线程束：线程调度、管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cuda错误检查&#34;&gt;CUDA错误检查
&lt;/h2&gt;&lt;h3 id=&#34;运行时错误检测&#34;&gt;运行时错误检测
&lt;/h3&gt;&lt;p&gt;所有CUDA运行时API函数都是以cuda为前缀的，而且都有一个类型为cudaError_t的返回值，代表了一种错误信息。只有返回值为cudaSuccess时才代表成功地调用了API函数。&lt;/p&gt;
&lt;h3 id=&#34;功能正确性检查&#34;&gt;功能正确性检查
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;内存检查、越界访问、异常检查等&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;./Tools.md&#34; &gt;checktool&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;获得gpu加速的关键&#34;&gt;获得GPU加速的关键
&lt;/h2&gt;&lt;h3 id=&#34;cuda事件计时&#34;&gt;CUDA事件计时
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cudaEvent_t start, stop;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CHECK(cudaEventCreate(&amp;amp;start));
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CHECK(cudaEventCreate(&amp;amp;stop));
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CHECK(cudaEventRecord(start));
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cudaEventQuery(start); // 此处不能用 CHECK 宏函数，对处于TCC 驱动模式的 GPU 来说可以省略，但对处于 WDDM 驱动模式的GPU来说必须保留。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;需要计时的代码块
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CHECK(cudaEventRecord(stop));
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CHECK(cudaEventSynchronize(stop));
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;float elapsed_time;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CHECK(cudaEventElapsedTime(&amp;amp;elapsed_time, start, stop));
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;printf(&amp;#34;Time = %g ms.\n&amp;#34;, elapsed_time);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CHECK(cudaEventDestroy(start));
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CHECK(cudaEventDestroy(stop));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;程序性能分析&#34;&gt;程序性能分析
&lt;/h3&gt;&lt;p&gt;Nsight Compute，详见tools.md&lt;/p&gt;
&lt;h3 id=&#34;影响gpu加速的关键因素&#34;&gt;影响GPU加速的关键因素
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;数据传输的比例：主设数据传输&lt;/li&gt;
&lt;li&gt;算术强度（arithmeticintensity）：计算相比于数据传输耗时的占比&lt;/li&gt;
&lt;li&gt;并行规模：数据规模要尽量匹配SM等计算资源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此, 在编写与优化CUDA程序时，一定要想方设法（主要是指仔细设计算法）做到以下几点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少主机与设备之间的数据传输。&lt;/li&gt;
&lt;li&gt;提高核函数的算术强度。&lt;/li&gt;
&lt;li&gt;增大核函数的并行规模。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cuda中的数学函数库&#34;&gt;CUDA中的数学函数库
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/cuda/cuda-math-api/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.nvidia.com/cuda/cuda-math-api/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;单精度浮点数内建函数和数学函数（singleprecisionintrinsics and math functions）。使用该类函数时不需要包含任何额外的头文件。&lt;/li&gt;
&lt;li&gt;双精度浮点数内建函数和数学函数（doubleprecisionintrinsicsandmathfunctions）。使用该类函数时不需要包含任何额外的头文件。&lt;/li&gt;
&lt;li&gt;半精度浮点数内建函数和数学函数（halfprecisionintrinsicsandmathfunctions）。使用该类函数时需要包含头文件&amp;lt;cuda_fp16.h&amp;gt;。&lt;/li&gt;
&lt;li&gt;整数类型的内建函数（integerintrinsics）。使用该类函数时不需要包含任何额外的头文件。&lt;/li&gt;
&lt;li&gt;类型转换内建函数（typecasting intrinsics）。使用该类函数时不需要包含任何额外的头文件。&lt;/li&gt;
&lt;li&gt;单指令-多数据内建函数（SIMDintrinsics）。使用该类函数时不需要包含任何额外的头文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;内存组织&#34;&gt;内存组织
&lt;/h2&gt;&lt;p&gt;分层思想，平衡成本和效率（在编码中体现为高内聚、低耦合）
&lt;img src=&#34;https://loveleaves.github.io/imgs/gpu_1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
&lt;img src=&#34;https://loveleaves.github.io/imgs/gpu_2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-variable-specifier&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-variable-specifier&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;不同硬件架构的内存编排不一定相同&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;全局内存global-memory&#34;&gt;全局内存（global memory）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;核函数中的所有线程都能够访问其中的数据，容量是所有设备内存中最大的。基本上就是显存容量。&lt;/li&gt;
&lt;li&gt;主要为核函数提供数据，并在主机与设备及设备与设备之间传递数据。&lt;/li&gt;
&lt;li&gt;host端访问数据：使用runtime接口&lt;code&gt;cudaGetSymbolAddress() / cudaGetSymbolSize() / cudaMemcpyToSymbol() / cudaMemcpyFromSymbol()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;同步函数&lt;code&gt;__syncthreads()&lt;/code&gt;：只是针对同一个线程块中的线程的，不同线程块中线程的执行次序依然是不确定的（不同线程块数据要保证不依赖）。&lt;/li&gt;
&lt;li&gt;在CUDA中还有一种内部构造对用户不透明的（nottransparent）全局内存，称为CUDAArray。CUDAArray使用英伟达公司不对用户公开的数据排列方式，专为纹理拾取服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;动态全局内存&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生命周期（lifetime）不是由核函数决定的，而是由主机端决定的（cudaMalloc、cudaFree）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;静态全局内存&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态全局内存变量&lt;/strong&gt;由以下方式在任何函数外部定义：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;__device__ T x; // 单个变量
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;__device__ T y[N]; // 固定长度的数组
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;在核函数中，可直接对静态全局内存变量进行访问，并不需要将它们以参数的形式传给核函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常量内存constant-memory&#34;&gt;常量内存（constant memory）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;有常量缓存的全局内存，一共仅有64KB，位于常量内存空间，核函数外部用&lt;code&gt;__constant__&lt;/code&gt;定义。&lt;/li&gt;
&lt;li&gt;它的可见范围和生命周期与全局内存一样，host端访问数据与全局内存一样。
由于有缓存，常量内存的访问速度比全局内存高，但得到高访问速度的前提是一个线程束中的线程（一个线程块中相邻的32个线程）要读取相同的常量内存数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;纹理内存texture-memory和表面内存surface-memory&#34;&gt;纹理内存（texture memory）和表面内存（surface memory）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;类似于常量内存，也是一种具有缓存的全局内存，有相同的可见范围和生命周期，而且一般仅可读（表面内存也可写）。不同的是，纹理内存和表面内存容量更大，而且使用方式和常量内存也不一样。&lt;/li&gt;
&lt;li&gt;对于计算能力5.0以上的GPU来说，将某些只读全局内存数据用&lt;code&gt;__ldg()&lt;/code&gt;函数通过只读数据缓存（read-onlydatacache）读取，既可达到使用纹理内存的加速效果，又可使代码简洁。对帕斯卡架构和更高的架构来说，全局内存的读取在默认情况下就利用了__ldg()函数，所以不需要明显地使用它。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;寄存器register和-局部内存local-memory&#34;&gt;寄存器（register）和 局部内存（local memory）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;存储函数入参、内建变量和临时变量等，32位。&lt;/li&gt;
&lt;li&gt;计算能力5.0~9.0的GPU，每个中都是64K的寄存器数量，Fermi架构只有32K；&lt;/li&gt;
&lt;li&gt;考虑：每个线程块使用的最大数量、每个线程的最大寄存器数量&lt;/li&gt;
&lt;li&gt;局部内存是全局内存的一部分，寄存器溢出是保存在局部内存中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;共享内存shared-memory&#34;&gt;共享内存（shared memory）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;和寄存器类似，存在于芯片上，具有仅次于寄存器的读写速度，&lt;code&gt;extern __shared__ float shared[]&lt;/code&gt;定义，数组大小在运行时确定,或&lt;code&gt;__shared__ float shared[100]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;共享内存对整个线程块可见，其生命周期也与整个线程块一致。&lt;/li&gt;
&lt;li&gt;一个线程块中的所有线程都可以访问该线程块的共享内存变量副本，但是不能访问其他线程块的共享内存变量副本。&lt;/li&gt;
&lt;li&gt;注意避免n路bank冲突（n很大场景，类似TLB组相联）：共享内存在物理上被分为32个（刚好等于一个线程束中的线程数目，即内建变量warpSize的值）同样宽度的、能被同时访问的内存bank。在所有其他架构中，每个bank的宽度为4字节。当同一线程束内的多个线程不同时访问同一个bank中不同层的数据，该线程束对共享内存的访问就只需要一次内存事务（memory transaction）,就会发生bank冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;l1-和-l2-缓存&#34;&gt;L1 和 L2 缓存
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;从费米架构开始，有了SM层次的L1缓存和设备（一个设备有多个SM）层次的L2缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sm及其占有率&#34;&gt;SM及其占有率
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;SM（Streaming MultiProcessor）构成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个GPU是由多个SM构成的。一个SM包含如下资源（不同架构不一定相同）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一定数量的寄存器。&lt;/li&gt;
&lt;li&gt;一定数量的共享内存。&lt;/li&gt;
&lt;li&gt;常量内存的缓存。&lt;/li&gt;
&lt;li&gt;纹理和表面内存的缓存。&lt;/li&gt;
&lt;li&gt;L1缓存。&lt;/li&gt;
&lt;li&gt;两个（计算能力6.0）或4个（其他计算能力）线程束调度器（warpscheduler），用于在不同线程的上下文之间迅速地切换，以及为准备就绪的线程束发出执行指令。&lt;/li&gt;
&lt;li&gt;执行核心，包括：
&lt;ul&gt;
&lt;li&gt;若干整型数运算的核心（INT32）。&lt;/li&gt;
&lt;li&gt;若干单精度浮点数运算的核心（FP32）。&lt;/li&gt;
&lt;li&gt;若干双精度浮点数运算的核心（FP64）。&lt;/li&gt;
&lt;li&gt;若干单精度浮点数超越函数（transcendentalfunctions）的特殊函数单元（Special Function Units，SFUs）。&lt;/li&gt;
&lt;li&gt;若干混合精度的张量核心（tensorcores，由伏特架构引入，适用于机器学习中的低精度矩阵计算）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;SM管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GPU中每个SM都可以支持数百个线程&lt;strong&gt;并发&lt;/strong&gt;执行&lt;/li&gt;
&lt;li&gt;以线程块block为单位，向SM分配线程块，多个线程块可被同时分配到一个可用的SM上&lt;/li&gt;
&lt;li&gt;当一个线程块被分配好后，就不可以在分配到其他上了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;线程束（warp）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CUDA 采用单指令多线程架构管理执行线程，每32个为一组，构成一个线程束。同一个线程块中相邻的 32个线程构成一个线程束&lt;/li&gt;
&lt;li&gt;每个线程束中只能包含同一线程块中的线程&lt;/li&gt;
&lt;li&gt;线程束是GPU硬件上真正的做到了&lt;strong&gt;并行&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;** SM 的占有率**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般来说，要尽量让SM的占有率不小于某个值，比如%，才有可能获得较高的性能。&lt;/li&gt;
&lt;li&gt;SM的理论占有率（theoreticaloccupancy）的两个指标:
&lt;ul&gt;
&lt;li&gt;一个SM中最多能拥有的&lt;strong&gt;线程块个数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一个SM中最多能拥有的&lt;strong&gt;线程个数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;根据寄存器、共享内存等具体架构具体分析&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;高效正确地并发并行&#34;&gt;高效正确地并发并行
&lt;/h2&gt;&lt;h3 id=&#34;原子函数atomic-function&#34;&gt;原子函数（atomic function）
&lt;/h3&gt;&lt;p&gt;cuda提供原子函数来进行控制数据一致性读写。其中&lt;code&gt;atomicCAS&lt;/code&gt;函数是比较特殊的，所有其他原子函数都可以用它实现（指定架构不支持时，但性能可能较差）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Atomic APIs with &lt;code&gt;_system&lt;/code&gt; suffix (example: &lt;code&gt;atomicAdd_system&lt;/code&gt;) are atomic at scope &lt;code&gt;cuda::thread_scope_system&lt;/code&gt; if they meet particular &lt;a class=&#34;link&#34; href=&#34;https://nvidia.github.io/cccl/libcudacxx/extended_api/memory_model.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;conditions&lt;/a&gt;. compute capability must greater than 7.2.&lt;/li&gt;
&lt;li&gt;Atomic APIs without a suffix (example: &lt;code&gt;atomicAdd&lt;/code&gt;) are atomic at scope &lt;code&gt;cuda::thread_scope_device&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Atomic APIs with &lt;code&gt;_block&lt;/code&gt; suffix (example: &lt;code&gt;atomicAdd_block&lt;/code&gt;) are atomic at scope &lt;code&gt;cuda::thread_scope_block&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://loveleaves.github.io/imgs/gpu_3.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;atomic&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;线程束warp基本函数&#34;&gt;线程束（warp）基本函数
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一个SM以32个线程为单位产生、管理、调度、执行线程。这样的32 个线程称为一个&lt;strong&gt;线程束&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;SM执行属于单指令-多线程（single instruction, multiple thread，&lt;strong&gt;SIMT&lt;/strong&gt;）的执行模式：在同一时刻，一个线程束中的线程只能执行一个共同的指令或者闲置。&lt;/li&gt;
&lt;li&gt;在伏特架构之前，一个线程束中的线程拥有同一个程序计数器（programcounter），但各自有不同的寄存器状态（registerstate），从而可以根据程序的逻辑判断选择不同的分支。因此当&lt;strong&gt;同一个线程束&lt;/strong&gt;（不同的不会）中的线程顺序地执行判断语句中的不同分支时，会发生&lt;strong&gt;分支发散&lt;/strong&gt;（branch divergence）。&lt;/li&gt;
&lt;li&gt;从&lt;strong&gt;伏特架构&lt;/strong&gt;开始，引入了独立线程调度（independentthreadscheduling）机制。每个线程有自己的程序计数器。这使得伏特架构有了一些以前的架构所没有的新的线程束内同步与通信的模式，但导致：
&lt;ul&gt;
&lt;li&gt;增加了寄存器负担：单个线程的程序计数器一般需要使用两个寄存器。&lt;/li&gt;
&lt;li&gt;独立线程调度机制使得假设了线程束同步（warpsynchronous）的代码变得不再安全：必须显式同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程束内的线程同步函数：都在一个线程束内时，可以将线程块同步函数&lt;code&gt;__syncthreads&lt;/code&gt; 换成一个更加廉价的线程束同步函数&lt;code&gt;__syncwarp&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#warp-vote-functions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;其他基本函数&lt;/a&gt;：
&lt;ul&gt;
&lt;li&gt;线程束表决函数（warpvotefunctions）&lt;/li&gt;
&lt;li&gt;线程束匹配函数（warpmatchfunctions）&lt;/li&gt;
&lt;li&gt;线程束洗牌函数（warp shuffle functions）&lt;/li&gt;
&lt;li&gt;线程束矩阵函数（warp matrix functions）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;协作组cooperativegroups&#34;&gt;协作组（cooperativegroups）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;类似线程块和线程束同步机制的推广，它提供了更为灵活的线程协作方式，包括线程块内部的同步与协作、线程块之间的（网格级的）同步与协作及设备之间的同步与协作。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#introduction-cg&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#introduction-cg&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cuda流cuda-stream&#34;&gt;CUDA流（CUDA stream）
&lt;/h2&gt;&lt;h3 id=&#34;cuda流介绍&#34;&gt;CUDA流介绍
&lt;/h3&gt;&lt;p&gt;主要用cuda流解决&lt;strong&gt;核函数外部&lt;/strong&gt;的并行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核函数计算与数据传输之间的并行。&lt;/li&gt;
&lt;li&gt;主机计算与数据传输之间的并行。&lt;/li&gt;
&lt;li&gt;不同的数据传输（回顾一下cudaMemcpy函数中的第4个参数）之间的并行。&lt;/li&gt;
&lt;li&gt;核函数计算与主机计算之间的并行。&lt;/li&gt;
&lt;li&gt;不同核函数之间的并行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;任何CUDA操作都存在于某个CUDA流中，要么是默认流（default stream），也称为空流（null stream），要么是明确指定的非空流。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在主机端产生与销毁。一个CUDA流由类型为cudaStream_t 的变量表示，&lt;code&gt;cudaStreamCreate&lt;/code&gt;和&lt;code&gt;cudaStreamDestroy&lt;/code&gt;创建和销毁。&lt;/li&gt;
&lt;li&gt;为了实现不同CUDA流之间的并发，主机在向某个CUDA流中发布一系列命令之后必须马上获得程序的控制权，不用等待该CUDA流中的命令在设备中执行完毕。这样，就可以通过主机产生多个相互独立的CUDA流。&lt;/li&gt;
&lt;li&gt;检查一个CUDA流中的所有操作是否都在设备中执行完毕：&lt;code&gt;cudaStreamSynchronize&lt;/code&gt;同步、&lt;code&gt;cudaStreamQuery&lt;/code&gt;查询&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;默认流default-stream-为空流null-stream&#34;&gt;默认流（default stream）/ 为空流（null stream）
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;两种调用方式：
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;my_kernel&amp;lt;&amp;lt;&amp;lt;N_grid, N_block&amp;gt;&amp;gt;&amp;gt;(函数参数);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;my_kernel&amp;lt;&amp;lt;&amp;lt;N_grid, N_block, N_shared&amp;gt;&amp;gt;&amp;gt;(函数参数);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;核函数的启动是异步的（asynchronous），或者说是非阻塞的（non-blocking），所以会host会立即执行下一条语句。该命令如果是CUDA操作不会被device立即执行，因为这是默认流中的CUDA操作，必须等待前一个CUDA操作（即核函数的调用）执行完毕才会开始执行。&lt;/li&gt;
&lt;li&gt;可以在核函数启动后放置host操作，利用前面CUDA操作完成时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;非默认流非空流&#34;&gt;非默认流/非空流
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;调用方式：
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;my_kernel&amp;lt;&amp;lt;&amp;lt;N_grid, N_block, N_shared, stream_id&amp;gt;&amp;gt;&amp;gt;(函数参数);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;my_kernel&amp;lt;&amp;lt;&amp;lt;N_grid,N_block, 0 ,stream_id&amp;gt;&amp;gt;&amp;gt;(函数参数); // 不使用动态共享内存
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# stream_id是CUDA流的编号，N_shared是核函数中使用的动态共享内存的字节数。
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;用非默认CUDA流重叠核函数的执行与数据传递&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要实现核函数执行与数据传输的并发（重叠），必须让这两个操作处于&lt;strong&gt;不同的非默认流&lt;/strong&gt;，而且数据传输必须使用cudaMemcpy函数的异步版本，即&lt;code&gt;cudaMemcpyAsync&lt;/code&gt;函数。异步传输由GPU中的DMA（directmemoryaccess）直接实现，不需要主机参与。&lt;/li&gt;
&lt;li&gt;在使用异步的数据传输函数时，需要将主机内存定义为不可分页内存（non-pageable memory）或者固定内存（pinned memory），在程序运行期间，其物理地址将保持不变，由&lt;code&gt;cudaMallocHost&lt;/code&gt;和&lt;code&gt;cudaFreeHost&lt;/code&gt;申请和释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;统一内存unifiedmemory编程&#34;&gt;统一内存（unifiedmemory）编程
&lt;/h2&gt;&lt;h3 id=&#34;介绍-1&#34;&gt;介绍
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;统一内存是一种逻辑上的概念，一种系统中的任何处理器（CPU或GPU）都可以访问，并能保证一致性的虚拟存储器。这种虚拟存储器是通过CPU和GPU各自内部集成的内存管理单元（memorymanagementunit）实现的。&lt;/li&gt;
&lt;li&gt;使用统一内存对硬件有较高的要求：不低于开普勒架构等。&lt;/li&gt;
&lt;li&gt;好处：不用手动内存传输管理；相比手动内存操作可能会有更好的性能；超量分配，类似虚拟内存策略。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;基本使用&#34;&gt;基本使用
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;统一内存在设备中是当作全局内存使用的，而且必须在主机端定义或分配内存，而不能在设备端（核函数和&lt;code&gt;__device__&lt;/code&gt;函数）定义或分配内存。&lt;/li&gt;
&lt;li&gt;动态申请：&lt;code&gt;cudaMallocManaged&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;静态申请：&lt;code&gt; __device____managed__int ret[1000];&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据预取：&lt;code&gt;cudaMemPrefetchAsync&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多gpu编程&#34;&gt;多GPU编程
&lt;/h2&gt;&lt;h2 id=&#34;cuda标准库&#34;&gt;CUDA标准库
&lt;/h2&gt;&lt;p&gt;cuda所以接口及库详见官网：&lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/cuda/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cuda docs&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://developer.nvidia.com/cuda-zone&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cuda developer&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;thrust&#34;&gt;Thrust
&lt;/h3&gt;&lt;p&gt;类似于C++的标准模板库（standard template library）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/NVIDIA/thrust&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;thrust&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://github.com/nvidia/cccl&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;NCCL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;数据结构：容器&lt;code&gt;thrust::host_vector&amp;lt;typename&amp;gt;&lt;/code&gt;和&lt;code&gt;thrust::device_vector&amp;lt;typename&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;算法：
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;变换（transformation）。本书多次讨论的数组求和计算就是一种变换操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;规约（reduction）。这是本书重点讨论过的算法。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;前缀和（prefixsum）。下一节将详细讨论该算法。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;排序（sorting）与搜索（searching）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;选择性复制、替换、移除、分区等重排（reordering）操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cublasbasic-linear-algebra-subprograms&#34;&gt;cuBLAS（basic linear algebra subprograms）
&lt;/h3&gt;&lt;p&gt;基本线性代数子程序，矩阵在内存中的存储是列主序（column-major order）的Fortran 风格，而不是像C语言中是行主序（row-majororder）的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/cuda/cublas/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cublas&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://www.netlib.org/blas/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;blas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;cuBLAS 库包含3个API：
&lt;ul&gt;
&lt;li&gt;cuBLAS API：相关数据必须在设备。&lt;/li&gt;
&lt;li&gt;cuBLASXTAPI：相关数据必须在主机。&lt;/li&gt;
&lt;li&gt;cuBLASLt API：一个专门处理矩阵乘法的API。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cufft&#34;&gt;cuFFT
&lt;/h3&gt;&lt;p&gt;快速傅里叶变换（fast Fourier transforms）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/cuda/cufft/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cufft&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cusparse&#34;&gt;cuSPARSE
&lt;/h3&gt;&lt;p&gt;稀疏（sparse）矩阵&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/cuda/cusparse/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cusparse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;cusparse提供了一些稀疏矩阵、向量和稠密矩阵、向量的运算函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cusolver&#34;&gt;cuSolver
&lt;/h3&gt;&lt;p&gt;稠密（dense）矩阵和稀疏（sparse）矩阵计算库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cuSolver 专注于一些比较高级的线性代数方面的计算，如矩阵求逆和矩阵对角化，类似LAPACK库。基于cuBLAS和cuSPARSE两个更基础的库实现。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/cuda/cusolver/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cusolver&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://www.netlib.org/lapack/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lapack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;cuSolver 库由以下3个相互独立的子库组成：
&lt;ul&gt;
&lt;li&gt;cuSolverDN（DeNse, DN）：一个处理稠密矩阵线性代数计算的库。&lt;/li&gt;
&lt;li&gt;cuSolverSP（SParse, SP）：一个处理稀疏矩阵的线性代数计算的库。&lt;/li&gt;
&lt;li&gt;cuSolverRF（ReFactorization, RF）：一个特殊的处理稀疏矩阵分解的库。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cuSolver 库函数倾向于使用异步执行。为了保证一个cuSolver函数的工作已经完成，可以使用&lt;code&gt;cudaDeviceSynchronize() &lt;/code&gt;函数进行同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;curand&#34;&gt;cuRAND
&lt;/h3&gt;&lt;p&gt;与随机数生成有关的库,包含伪随机数（pseudorandom numbers）和准随机数（quasirandom numbers）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/cuda/curand/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;curand&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;cuRand是后向兼容（backward compatible）的，注意cuRAND 和 the CUDA runtime的版本对应&lt;/li&gt;
&lt;li&gt;提供了两种API：主机API和设备API。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cudnn&#34;&gt;cuDNN
&lt;/h3&gt;&lt;p&gt;深度神经网络（deep neural networks）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是一个用于深度神经网络的 GPU 加速基元库。cuDNN 为标准例程（如前向和后向卷积、注意力、matmul、池化和规范化）提供高度优化的实现。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/cudnn/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cudnn docs&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://developer.nvidia.com/cudnn&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cudnn developer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
