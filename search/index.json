[{"content":"设计模式简介 以下引用自菜鸟教程、design pattern\n设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。\n什么是 GOF（四人帮，全拼 Gang of Four）？ 在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。\n四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。\n对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 设计模式之美-王争 知识概览图 课程目录 文章导览 简介 开篇词 | 一对一的设计与编码集训，让你告别没有成长的烂代码！ 01 | 为什么说每个程序员都要尽早地学习并掌握设计模式相关知识？ 02 | 从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？ 03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？ 04 | 理论一：当谈论面向对象的时候，我们到底在谈论什么？ 05 | 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？ 06 | 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？ 07 | 理论四：哪些代码设计看似是面向对象，实际是面向过程的？ 08 | 理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？ 09 | 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？ 10 | 理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？ 11 | 实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？ 12 | 实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？ 13 | 实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？ 14 | 实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？ 15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？ 16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？ 17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？ 18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？ 19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？ 20 | 理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？ 21 | 理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？ 22 | 理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？ 23 | 实战一（上）：针对业务系统的开发，如何做需求分析和设计？ 24 | 实战一（下）：如何实现一个遵从设计原则的积分兑换系统？ 25 | 实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？ 26 | 实战二（下）：如何实现一个支持各种统计规则的性能计数器？ 27 | 理论一：什么情况下要重构？到底重构什么？又该如何重构？ 28 | 理论二：为了保证重构不出错，有哪些非常能落地的技术手段？ 29 | 理论三：什么是代码的可测试性？如何写出可测试性好的代码？ 30 | 理论四：如何通过封装、抽象、模块化、中间层等解耦代码？ 31 | 理论五：让你最快速地改善代码质量的20条编程规范（上） 32 | 理论五：让你最快速地改善代码质量的20条编程规范（中） 33 | 理论五：让你最快速地改善代码质量的20条编程规范（下） 34 | 实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题 35 | 实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用” 36 | 实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？ 37 | 实战二（下）：重构ID生成器项目中各函数的异常处理代码 38 | 总结回顾面向对象、设计原则、编程规范、重构技巧等知识点 39 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（上） 40 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（下） 41 | 单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？ 42 | 单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？ 43 | 单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？ 44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？ 45 | 工厂模式（下）：如何设计实现一个Dependency Injection框架？ 46 | 建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式 47 | 原型模式：如何最快速地clone一个HashMap散列表？ 48 | 代理模式：代理在RPC、缓存、监控等场景中的应用 49 | 桥接模式：如何实现支持不同类型和渠道的消息推送系统？ 50 | 装饰器模式：通过剖析Java IO类库源码学习装饰器模式 51 | 适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？ 52 | 门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？ 53 | 组合模式：如何设计实现支持递归遍历的文件系统目录树结构？ 54 | 享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？ 55 | 享元模式（下）：剖析享元模式在Java Integer、String中的应用 56 | 观察者模式（上）：详解各种应用场景下观察者模式的不同实现方式 57 | 观察者模式（下）：如何实现一个异步非阻塞的EventBus框架？ 58 | 模板模式（上）：剖析模板模式在JDK、Servlet、JUnit等中的应用 59 | 模板模式（下）：模板模式与Callback回调函数有何区别和联系？ 60 | 策略模式（上）：如何避免冗长的if-else/switch分支判断代码？ 61 | 策略模式（下）：如何实现一个支持给不同大小文件排序的小程序？ 62 | 职责链模式（上）：如何实现可灵活扩展算法的敏感信息过滤框架？ 63 | 职责链模式（下）：框架中常用的过滤器、拦截器是如何实现的？ 64 | 状态模式：游戏、工作流引擎中常用的状态机是如何实现的？ 65 | 迭代器模式（上）：相比直接遍历集合数据，使用迭代器有哪些优势？ 66 | 迭代器模式（中）：遍历集合的同时，为什么不能增删集合元素？ 67 | 迭代器模式（下）：如何设计实现一个支持“快照”功能的iterator？ 68 | 访问者模式（上）：手把手带你还原访问者模式诞生的思维过程 69 | 访问者模式（下）：为什么支持双分派的语言不需要访问者模式？ 70 | 备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？ 71 | 命令模式：如何利用命令模式实现一个手游后端架构？ 72 | 解释器模式：如何设计实现一个自定义接口告警规则功能？ 73 | 中介模式：什么时候用中介模式？什么时候用观察者模式？ 74 | 总结回顾23种经典设计模式的原理、背后的思想、应用场景等 75 | 在实际的项目开发中，如何避免过度设计？又如何避免设计不足？ 76 | 开源实战一（上）：通过剖析Java JDK源码学习灵活应用设计模式 77 | 开源实战一（下）：通过剖析Java JDK源码学习灵活应用设计模式 78 | 开源实战二（上）：从Unix开源开发学习应对大型复杂项目开发 79 | 开源实战二（中）：从Unix开源开发学习应对大型复杂项目开发 80 | 开源实战二（下）：从Unix开源开发学习应对大型复杂项目开发 81 | 开源实战三（上）：借Google Guava学习发现和开发通用功能模块 82 | 开源实战三（中）：剖析Google Guava中用到的几种设计模式 83 | 开源实战三（下）：借Google Guava学习三大编程范式中的函数式编程 84 | 开源实战四（上）：剖析Spring框架中蕴含的经典设计思想或原则 85 | 开源实战四（中）：剖析Spring框架中用来支持扩展的两种设计模式 86 | 开源实战四（下）：总结Spring框架用到的11种设计模式 87 | 开源实战五（上）：MyBatis如何权衡易用性、性能和灵活性？ 88 | 开源实战五（中）：如何利用职责链与代理模式实现MyBatis Plugin？ 89 | 开源实战五（下）：总结MyBatis框架中用到的10种设计模式 90 | 项目实战一：设计实现一个支持各种算法的限流框架（分析） 91 | 项目实战一：设计实现一个支持各种算法的限流框架（设计） 92 | 项目实战一：设计实现一个支持各种算法的限流框架（实现） 93 | 项目实战二：设计实现一个通用的接口幂等框架（分析） 94 | 项目实战二：设计实现一个通用的接口幂等框架（设计） 95 | 项目实战二：设计实现一个通用的接口幂等框架（实现） 96 | 项目实战三：设计实现一个支持自定义规则的灰度发布组件（分析） 97 | 项目实战三：设计实现一个支持自定义规则的灰度发布组件（设计） 98 | 项目实战三：设计实现一个支持自定义规则的灰度发布组件（实现） 99 | 总结回顾：在实际软件开发中常用的设计思想、原则和模式 100 | 如何将设计思想、原则、模式等理论知识应用到项目中？ 加餐一 | 用一篇文章带你了解专栏中用到的所有Java语法 加餐二 | 设计模式、重构、编程规范等相关书籍推荐 春节特别加餐 | 王争：如何学习《设计模式之美》专栏？ 加餐三 | 聊一聊Google是如何做Code Review的 加餐四 | 聊一聊Google那些让我快速成长的地方 加餐五 | 听一听小争哥对Google工程师文化的解读 加餐六 | 什么才是所谓的编程能力？如何考察一个人的编程能力？ 加餐七 | 基础学科的知识如何转化成实际的技术生产力？ 加餐八 | 程序员怎么才能让自己走得更高、更远？ 加餐九 | 作为面试官或候选人，如何面试或回答设计模式问题？ 加餐十 | 如何接手一坨烂业务代码？如何在烂业务代码中成长？ 结束语 | 聊一聊机遇、方向、能力、努力！ MVC和DDD 两者对比：业务开发常用的基于贫血模型的MVC架构违背OOP吗\nMVC MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。 https://www.runoob.com/design-pattern/mvc-pattern.html 基于贫血模型的传统的开发模式，是一种彻彻底底的面向过程的编程风格 DDD 领域驱动设计（Domain Driven Design，简称DDD） 基于充血模型的开发模式，面向对象编程风格 UML UML介绍 UML：Unified Modeling Language（统一建模语言），使用UML进行建模的作用有哪些：\n可以更好的理解问题 可以及早的发现错误或者被遗漏的点 可以更加方便的进行组员之间的沟通 支持面向对象软件开发建模，可以更好的描述显示编程的情景。 对于复杂的系统来说，如果概要模型做的好，那么整个系统的模型也就很清晰明了。 References UML教程 UML2.5笔记 ＵＭＬ基础与建模实践教程 Tools 在线免费：https://www.processon.com/ ","date":"2025-02-09T00:00:00Z","permalink":"https://loveleaves.github.io/p/design_pattern/","title":"【软件设计】 设计模式介绍"},{"content":"ARM SIMD ARM平台基于ARM v7-A架构的ARM Cortex-A系列处理器(Cortex-A5, Cortex-A7,Cortex-A8, Cortex-A9, Cortex-A15)上的NEON加速：\n针对C/C++语言：循环展开等编译优化，-O2启用 针对NEON intrinsics：NEOM SIMD C/C++语言接口，针对架构启用V向量扩展，选择浮点处理器和ABI（application Binary Interface）接口类型 针对汇编语言：内联汇编，直接操作neon指令和寄存器 路线：了解相应编译优化=》使用intrinsic接口，学习对应汇编代码=》内联汇编，在编译器汇编代码基础上（否则可能反优化）学习并优化 references NEON Programmer\u0026rsquo;s Guide Cortex-A Series Programmer\u0026rsquo;s Guide 算子源码 AI算子：腾讯ncnn 数据处理算子：numpy simd 图像处理算子：Nvidia carotene，OpenCV third party 理论学习 指令流水线 经典的五级流水线模型 1、取指（IF）\n以程序计数器（PC）中的内容作为地址，从存储器中取出指令并放入指令寄存器（IR）； PC值加4（假设每条指令占4字节），指向顺序的下一条指令。 2、指令译码/读寄存器周期（ID）\n对指令进行译码，并用IR中的寄存器地址去访问通用寄存器组，读出所需的操作数； 对IR中的立即数进行扩展 3、执行/有效地址计算周期（EX）\nALU对上一个周期中准备好的操作数进行运算或处理。在这个阶段，不同类型的指令进行的操作不同。\n（1）load和store指令：ALB把指令中所指定的寄存器的内容与偏移量相加，形成访存有效地址； （2）寄存器-寄存器 ALU 指令：ALU按照操作码指定的操作对从通用寄存器组中读出的数据进行运算； （3）寄存器-立即数 ALU 指令：ALU按照操作码指定的操作对从通用寄存器组中读出的操作数和指令中给出的立即数进行运算； （4）分支指令：ALU把指令中给出的偏移量与PC值相加，形成转移目标的地址。同时，对在前一个周期读出的操作数进行判断，确定分支是否成功。 4、存储器访问/分支完成周期（MEM）\n（1）load和store指令：load指令根据上一个周期计算出的有效地址从存储器中读出的相应的数据；store把指定的数据写入这个有效地址对应的存储单元。 （2）分支指令：如果分支“成功”，就把前一个周期中计算好的转移目标地址送入PC。分支指令执行完成；否则，就不进行任何操作。 5、写回周期（WB）\n把结果写入通用寄存器组。对于ALU运算来说，这个结果来自ALU，而对于load指令来说，这个结果来自存储器。 SIMD加速原理 《计算机体系结构：量化研究方法》。Neon是ARM平台的SIMD（Single Instruction Multiple Data，单指令多数据流）指令集实现，书中4.1~4.3讨论了SIMD，推荐阅读。 之所以能加速的原因总结：\n（1）通过加长的寄存器减少数据的读取/写入次数，从而减少将数据读入寄存器的时间开销。例如Neon可以一次性将16个int8（16*8=128bit）数据读入专用寄存器，这一次读取时间开销，明显少于16个int8数据一个一个地读入的时间之和。写入同理。（注意不要和cache的减少访存时间的原理混淆。从cache读取余下的第2~第16个int8数据到寄存器仍然是要花费时钟周期的）。 （2）执行SISD（single instruction, Single data，单指令流单数据流，这里可理解为标量计算）指令时，需要完成（时间开销大的）冒险（hazard）检查。既然使用SIMD指令计算，就暗示这些数据之间无依赖性，也就从指令集层面回避了不必要的时间开销。 了解硬件决定的速度极限：Software Optimization Guide 我们可能还要关心，我们所编写的Neon Intrinsics，可以将手头上硬件的性能发挥到多少水平？是否还有提升空间？这些是好问题。\n在讨论一个问题前，先插入一个使笔者拍案叫绝的相关案例：在另一本计算经典《深入理解计算机系统》 （一般简称 CS:APP）的第5章 优化程序性能 中，该书作者考虑若干计算机硬件特性，将矩阵乘法连续优化了6个版本，直至优化到了该x86 CPU的吞吐量上限（注：对于某种指令，延迟latency 主要关注单条该指令的最小执行时间，吞吐量throughout主要关注单位时间内系统（一个CPU核）最多执行多少条该指令。因为AI计算的数据量比较大，我们更关注吞吐量） 回到问题，我们需要知道我们的吞吐量上界是多少。ARM官方为每个CPU架构（手机CPU一般大核是A7X架构，小核是A5X架构）提供对应的Software Optimization Guide，里面有进行各种运算的latency和throughout。以A76架构（采用该架构作为大核架构的CPU例如骁龙855，麒麟980）为例子，从ARM官网下载对应的pdf（https://developer.arm.com/documentation/swog307215/a/?lang=en） 翻到ASIMD（Advance SIMD）那里，就能查阅各条Neon指令相应的latency和throughout。不同架构的吞吐量上界会有所不同，其他架构请自行在ARM官网文档中心下载。 理论数据有了，至于如何通过实验测试峰值，可参考BBuf的文章 如何判断算法是否有可优化空间？ （https://zhuanlan.zhihu.com/p/268925243）\n反汇编分析生成代码质量 可通过反汇编的方式查看Intrinsics 生成的汇编是否满足预期，如果不满足预期则进行手写汇编优化。具体操作可参考梁德澎的文章 移动端arm cpu优化学习笔记第4弹\u0026ndash;内联汇编入门（https://zhuanlan.zhihu.com/p/143328317）\nmaterials （1）研讨会视频 \u0026ldquo;Performance Analysis for Optimizing Embedded Deep Learning Inference Software,\u0026rdquo; a Presentation from Arm - Edge AI and Vision Alliance，建立优化分析思维 （2）研讨会视频 LCU14-504: Taming ARMv8 NEON: from theory to benchmark results （3）研讨会视频 HKG15-408: ARM v8-A NEON optimization （4）Ne10（ARM官方的计算库）：https://github.com/projectNe10/Ne10 （5）Arm Optimized Routines（ARM官方的计算、网络、字符串库）：https://github.com/ARM-software/optimized-routines （6）Neon优化Chromium的案例：https://developer.arm.com/documentation/101964/developer.arm.com NEON 介绍 ARM NEON 是 ARM 架构的一种 SIMD（Single Instruction, Multiple Data）扩展，旨在加速多媒体、数字信号处理（DSP）、图像处理、音视频编解码、加密算法等高并发计算任务。NEON 是 ARMv7 （ARMv7-A只支持单精度，32x64-bit寄存器；Armv8-A AArch64支持双精度，32x128-bit寄存器，针对浮点操作的Vector Floating Point，VFP）及之后版本的处理器的标准扩展，广泛用于智能手机、嵌入式设备、平板电脑以及其他移动设备中，尤其是处理需要并行化的计算密集型应用时，它能显著提高性能。\n重要概念 lane：如一个float32x4_t类型的变量float32x4_t v = {1.0f, 2.0f, 3.0f, 4.0f}，它占用 128 位，存储 4 个 32 位的浮点数，在这个向量寄存器 v 中，每个值依次存储在不同的lane序号为0、1、2、3中。 NEON 寄存器 定义：NEON 使用专门的寄存器来存储向量数据，这些寄存器通常用于处理多个数据元素，ARMv7-A只支持单精度，32x64-bit寄存器；Armv8-A AArch64支持双精度，32x128-bit寄存器。 作用：NEON 寄存器组包含了 128 （Q字母）或 64（D字母） 位宽的寄存器，可以存储多个 8 位、16 位、32 位、64 位整数或浮点数据。 例子： Q0-Q15：128 位宽的 NEON 寄存器，用于存储 8 位、16 位、32 位、64 位的数据（整数或浮点数）。 D0-D15：64 位宽的 NEON 寄存器，也用于存储 64 位数据。 向量和标量操作 定义：NEON 支持对向量（多个元素）和标量（单个元素）进行操作。 作用：标量操作是普通的逐元素操作，而向量操作则允许一次性处理多个数据元素。 例子： vadd.f32：向量浮点加法操作。 vadd.i32：向量整数加法操作。 NEON 数据类型 定义：NEON 支持多种数据类型，包括整数、浮点数、双精度浮点数和混合类型数据。 作用：不同的数据类型适应不同的应用需求，如 8 位整数、32 位浮点数等。 例子： i8, i16, i32, i64：不同宽度的整数类型。 f32, f64：浮点数类型，支持单精度和双精度浮点数。 NEON 指令集 定义：NEON 提供了一组专门的指令来处理数据并执行并行计算。NEON 指令包括加法、乘法、减法、移位、汇聚（归约）、比较、选择、数据类型转换等。 作用：这些指令能够加速处理向量数据，尤其是应用于图像处理、音频处理、视频编解码、加密算法等领域。 例子： vadd：向量加法指令。 vmul：向量乘法指令。 vsub：向量减法指令。 vmax：向量最大值选择指令。 扩展数据类型 定义：NEON 提供了扩展数据类型的支持，如高/低16位扩展、饱和算术、向量数据类型转换等。 作用：这种扩展数据类型用于在计算过程中执行高效的数据操作和转换，避免数据溢出或精度丢失。 例子： vshl：向左移位操作。 vqadd：饱和加法指令，防止数据溢出。 数据载入和存储指令 定义：NEON 提供了一些专门的加载（load）和存储（store）指令，用于从内存中加载数据到寄存器，或将寄存器中的数据存储回内存。 作用：这些指令能够优化内存访问，支持从多个内存地址加载和存储数据。 例子： vld1：加载向量数据指令。 vst1：存储向量数据指令。 数据汇聚和归约操作 定义：NEON 提供了对向量数据的汇聚（归约）操作，例如求和、最大值、最小值等。 作用：这些操作通常用于计算总和、平均值、最大值等统计量，广泛应用于信号处理和数据分析中。 例子： vaddv：对向量元素进行加法归约，返回所有元素的和。 vmaxv：对向量元素进行最大值归约，返回最大值。 条件执行 定义：NEON 支持条件执行，通过设置条件码（flags），可以对某些指令的执行进行条件限制。 作用：可以根据特定的条件执行指令，避免不必要的计算，提高性能。 例子： vsel：根据掩码（mask）选择性地执行指令。 SIMD 聚合指令（广播操作） 定义：NEON 支持广播操作，允许单一标量值扩展到整个向量中。广播操作使得标量与向量的数据处理更加简便。 作用：通过广播操作，标量可以与向量中的每个元素进行计算，提高了指令的灵活性。 例子： vdup：将一个标量值复制到整个向量中。 NEON 浮点数运算 定义：NEON 支持单精度浮点数和双精度浮点数的运算，符合 IEEE 754 标准。 作用：这些浮点数运算指令可用于科学计算、图像处理等应用。 例子： vadd.f32：单精度浮点数向量加法。 vmul.f32：单精度浮点数向量乘法。 数据类型转换 定义：NEON 支持多种类型之间的转换操作，如浮点与整数类型之间的转换。 作用：这种转换对于不同数据类型之间的运算非常重要，可以确保类型匹配并避免数据丢失。 例子： vcvt.f32.s32：将 32 位整数转换为 32 位单精度浮点数。 vcvt.s32.f32：将 32 位单精度浮点数转换为 32 位整数。 向量掩码 定义：NEON 支持通过掩码控制哪些向量元素应该被操作。掩码机制允许在处理多个数据时根据特定条件选择性地操作某些元素。 作用：掩码可以控制并行操作的粒度，提高计算的灵活性。 例子： vmla：向量乘加指令，根据掩码控制哪些元素参与计算。 NEON Intrinsic 兼容armv7和v8（部分指令可能不兼容），所以不同架构之间迁移方便，不需要改代码\nReferences NEON-Intrinsics Neon Programmer Guide for Armv8-A Coding for Neon intrinsics检索，用来查看接口和支持架构 ARM Neon Intrinsics 学习指北：从入门、进阶到学个通透 numpy simd 数据和计算指令类型的格式 1、向量数据类型格式：\u0026lt;type\u0026gt;\u0026lt;size\u0026gt;x\u0026lt;number of lanes\u0026gt;_t\n比如float32x4_t，=float,=32,=4 向量数据类型： 2、向量数组类型：\u0026lt;type\u0026gt;\u0026lt;size\u0026gt;x\u0026lt;number of lanes\u0026gt;x\u0026lt;length of array\u0026gt;_t\n比如 1 2 3 4 struct int16x4x2_t { int16x4_t val[2]; }; 向量指令格式：\u0026lt;opname\u0026gt;\u0026lt;flags\u0026gt;_\u0026lt;type\u0026gt;\n比如vmulq_f32，=vmul，=q,=f32 Note 普通计算逻辑考虑优化编译器优化、类型量化等 循环一般用do-while的形式 对于非整数倍元素个数的解决方法： leftovers 使用 NEON 的广播操作，避免显示复制数据 使用 NEON 的饱和操作，避免数据溢出 利用数据类型转换操作，并合理进行量化 利用shift、insert、mask等 计算机组成结构运行相关（通用） 并行\n充分利用计算机流水线：去除数据依赖 逻辑操作代替分支选择（分支预测） 数据预加载（预取/并行） 资源利用\n充分利用寄存器资源，分块处理数据，但避免寄存器溢出(Register Spilling）（测试时开启O2优化使编译器允许寄存器存储临时变量） 内存合理对齐分配，按对应寄存器长度读取 多线程处理，如OpenMP（并行/数据共享） 利用数据连续特性、利用cache NEON 汇编 可用__aarch64__宏区分是armv8，否则armv7，针对性编写代码\nReferences 移动端arm cpu优化学习笔记第4弹\u0026ndash;内联汇编入门 arm 内联汇编使用 arm内联汇编的一般格式，detail、docs\n1 2 3 4 5 6 7 8 __asm__ qualifiers ( // 汇编代码部分 : OutputOperands //在内联汇编代码中被修改的变量列表 : InputOperands //在内联汇编代码中用到的变量列表 : Clobbers //在内联汇编代码中用到的寄存器列表 ); Note 先写intrinsic代码反汇编，学习编译器优化后的汇编代码，再优化 重点关注指令流水线排布，避免CPU的Hazard ","date":"2025-02-06T00:00:00Z","permalink":"https://loveleaves.github.io/p/arm-neon/","title":"【SIMD】 ARM SIMD指令集NEON等介绍"},{"content":"References The RISC-V Instruction Set Manual Volume II: Privileged Architecture RVV spec Xuantie+900+Series+RVV-0.7.1+Intrinsic+Manual 算子源码 ARM-software/CMSIS, CMSIS-DSP Nuclei-software/NMSIS Note illegal instruction：修改CSR的mstatus标志位 important concepts VLEN (Vector Length) 定义：向量寄存器的长度，表示每个寄存器可以存储的最大元素数量，通常是硬件设定的，例如 128 位、256 位或 512 位。 作用：决定向量寄存器的容量和能处理的数据量。 例子： 如果 VLEN 为 256 位且每个元素为 32 位整数，则每个寄存器最多存储 8 个元素（256 / 32 = 8）。 SLEN (Stride Length) 定义：元素在内存中的步长，即两个连续元素之间的内存偏移量。 作用：影响内存访问模式，特别是在访问非连续内存时，SLEN 决定了元素之间的间隔。 例子： 假设一个向量寄存器存储 4 个元素，每个元素大小为 32 位，而 SLEN 设置为 2，这意味着每个向量元素在内存中的位置间隔为 2 个 32 位单元。 ELEN (Element Length) 定义：每个向量元素的大小（单位：比特），决定了每个元素占用多少内存。 作用：影响向量中每个元素的数据类型大小，在指令中用e表示，如e32。 例子： 如果 ELEN 设置为 32 位，则每个向量元素为 32 位宽，可以是一个 32 位整数或 32 位浮点数。 如果 ELEN 为 64 位，则每个元素占 64 位，适用于较大数据类型（如 64 位整数或浮点数）。 LMUL (Vector Register Grouping Factor) 定义：向量寄存器的分组因子，控制每个向量寄存器内元素的数量，决定寄存器的并行度。 作用：LMUL 会影响每个向量寄存器中包含的元素数量，从而影响并行性，在指令中用m表示，如m1。 例子： LMUL = 1：每个寄存器存储最大数量的元素（假设 VLEN = 256 位，ELEN = 32 位，则每个寄存器存储 8 个元素）。 LMUL = 2：每个寄存器只存储 4 个元素，寄存器总数增加，适合提高并行度。 LMUL = 4：每个寄存器只存储 2 个元素。 VL (Vector Length Register) 定义：VL 是一个寄存器，用来控制当前向量指令的长度，即当前指令能处理的元素数量。 作用：在 RVV 指令中，VL 决定了向量运算的迭代次数，向量操作将执行 VL 次。 例子： 如果 VL = 4，那么该指令将对前 4 个向量元素执行操作，用setvl(max)指令可以得到指令类型的最大元素数量，其中每个指令指定vl可处理不同数量的元素。 VTYPE (Vector Type Register) 定义：VTYPE 控制向量操作的类型，如元素长度 (ELEN) 和 LMUL 的配置。 作用：配置向量操作的具体参数，帮助硬件理解如何处理向量指令。 例子： VTYPE 设置为 ELEN = 32 位，LMUL = 1，表示每个向量寄存器存储 32 位元素，且每个寄存器的并行度为 1。 Vector Mask (vmsk) 定义：向量掩码用于控制哪些向量元素应该被操作，哪些应该被忽略。 作用：掩码机制使得程序能够选择性地执行向量操作。 例子： 若 vmsk = 11110000（二进制），则只有前 4 个向量元素会被操作，后 4 个元素将被忽略。 Vector Registers (v0 - vn) 定义：向量寄存器用于存储向量数据，RISC-V 定义了 v0 到 v31 的向量寄存器。 作用：这些寄存器用于存储和处理向量数据，数量和大小可由硬件决定。 例子： v0 和 v1 可以分别存储 256 位的向量数据，适用于不同长度的数据类型。 Vector Load/Store Instructions 定义：向量加载和存储指令，用于将数据从内存加载到向量寄存器，或将向量寄存器中的数据存储回内存。 作用：支持各种内存访问模式，如连续或非连续访问。 例子： vlb：加载字节数据到向量寄存器。 vsb：将字节数据存储回内存。 Vector Arithmetic Instructions 定义：向量算术指令用于执行向量加法、减法、乘法、除法等算术运算。 作用：向量算术指令在多核处理器中并行执行运算。 例子： vadd：向量加法，执行两个向量的逐元素加法。 vmul：向量乘法，执行两个向量的逐元素乘法。 Vector Compare Instructions 定义：向量比较指令用于比较向量中的元素，返回布尔掩码结果。 作用：常用于条件判断和控制流。 例子： vseq：判断两个向量的元素是否相等，结果返回掩码。 vsgt：判断向量元素是否大于另一个向量，返回布尔掩码。 Vector Reduction Instructions 定义：向量归约指令用于将向量中的多个元素归约为一个单一结果，如求和、求最大值等。 作用：常用于矩阵运算、图像处理等应用。 例子： vredsum：求和，将向量中所有元素相加。 vredmax：求最大值，返回向量中的最大元素。 Vector Scatter/Gather Instructions 定义：用于从非连续的内存地址中加载数据或将数据存储到非连续的内存地址。 作用：提高对非连续内存的访问效率。 例子： vscatter：将向量元素存储到不连续的内存位置。 vgather：从不连续的内存位置加载数据到向量寄存器。 Vector-Scalar Operations 定义：向量与标量之间的操作，允许标量与每个向量元素进行逐一运算。 作用：通过标量与向量元素的结合，处理常数数据。 例子： vaddvi：将一个标量与向量中的每个元素相加。 vmulvi：将一个标量与向量中的每个元素相乘。 Vector Predication 定义：根据掩码或布尔条件选择性执行向量操作。 作用：通过掩码决定哪些元素进行计算，哪些跳过。 例子： vmand：与掩码进行与运算，满足条件的元素进行计算。 Vector Tail \u0026amp; Masking 定义：当 VL 不能完全填充向量寄存器时，通过尾部掩码控制哪些元素需要操作。 作用：避免浪费计算资源，确保运算的有效性。 例子： 如果 VL = 5，而寄存器有 8 个元素，掩码将控制只操作前 5 个元素。 Vector Unit (VU) 定义：向量单元是硬件中的计算单元，负责执行向量指令。 作用：处理向量计算，提高处理器的并行度。 例子： 在支持 RVV 的处理器中，向量单元可以同时处理多个向量运算。 Note 常见使用方式 以float32类型dot计算为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void riscv_dot_prod_f32( const float32_t * pSrcA, const float32_t * pSrcB, uint32_t blockSize, float32_t * result) { float32_t sum = 0.0f; size_t blkCnt = blockSize; size_t l; vfloat32m8_t v_A, v_B; vfloat32m8_t vsum; l = __riscv_vsetvlmax_e32m8(); vsum = __riscv_vfmv_v_f_f32m8(0.0f, l); for (; (l = __riscv_vsetvl_e32m8(blkCnt)) \u0026gt; 0; blkCnt -= l) { v_A = __riscv_vle32_v_f32m8(pSrcA, l); pSrcA += l; v_B = __riscv_vle32_v_f32m8(pSrcB, l); pSrcB += l; vsum = __riscv_vfmacc_vv_f32m8(vsum, v_A, v_B, l); } l = __riscv_vsetvl_e32m8(1); vfloat32m1_t temp00 = __riscv_vfmv_v_f_f32m1(0.0f, l); l = __riscv_vsetvlmax_e32m8(); temp00 = __riscv_vfredusum_vs_f32m8_f32m1(vsum, temp00, l); sum = __riscv_vfmv_f_s_f32m1_f32(temp00); *result = sum; } ","date":"2025-02-06T00:00:00Z","permalink":"https://loveleaves.github.io/p/rvv/","title":"【SIMD】 Risc-v SIMD指令集RVV介绍"},{"content":"环境准备 1.1 Git下载 前往【Git官网】，下载安装程序 一直点下一步，默认安装即可\nHugo下载 前往【Hugo Github Tags】，选择对应版本下载，下载后解压即可 Windows下载版本：hugo_extended_xxxxx_windows_amd64.zip\n搭建博客 创建博客 （1）在hugo.exe所在文件夹的地址栏敲打cmd，然后Enter唤起命令行\n（2）敲打命令hugo new site xxxx创建hugo文件\n（3）敲打命名cd xxxx切换目录，并把hugo.exe复制到刚生成的文件夹中\n（4）敲打命令hugo server -D启动服务，访问http://localhost:1313，Ctrl+C停止服务 （hugo默认是没有主题的，需要进行主题配置）\n配置主题 （1）前往【Hugo Themes】，查找自己喜欢的主题，进行下载\n（2）这边以【Stack主题】为例，将下载好的主题解压，放到/themes文件夹中\n（3）将exampleSite样例数据中的 Content 和 hugo.yaml 复制到主文件夹中，并删掉hugo.toml和content/post/rich-content\n（4）修改 hugo.yaml 中的 theme，将他修改为跟主题文件夹同名\n（5）再次启动hugo服务，查看主题，具体主题配置修改 hugo.yaml，这里不细说，感兴趣可自行查找相关文章\n启用 Giscus 评论 Giscus 是利用 GitHub Discussions 实现的评论系统，开源、无跟踪、无广告、永久免费。\nHugo 对 Giscus 有很好的支持，在 hugo-theme-jane 主题中配置启用Giscus 很简单。\n要启用 Giscus 请先确保：\n仓库是公开的，否则访客将无法查看 discussions。 giscus app 已安装，否则访客将无法评论和回应。 Discussions 功能已在你的仓库中启用。 前面搭建的博客仓库就是公开的，满足了第一点，接下来要做的就是安装 Giscus app 和启用 Discussions。\nReferences https://www.codeaer.com/post/enable-giscus-comments-in-hugo/ 配置 Giscus 根据版本有所不同，0.143.1版本可使用以下模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # repoId、categoryId参考网址修改：https://giscus.app/zh-CN giscus: repo: \u0026#34;xxx/xxx.github.io\u0026#34; repoId: \u0026#34;xxx\u0026#34; category: \u0026#34;General\u0026#34; categoryId: \u0026#34;xxx\u0026#34; mapping: \u0026#34;pathname\u0026#34; # comment value is the default value strict: 0 reactionsEnabled: 1 # emitMetadata: 0 inputPosition: \u0026#34;top\u0026#34; theme: \u0026#34;dark\u0026#34; lang: \u0026#34;zh-CN\u0026#34; lazyLoading: true crossorigin: \u0026#34;anonymous\u0026#34; Github部署 常规部署 （1）前往【Github官网】，创建仓库 {github用户名}.github.io\n（2）前往Setting -\u0026gt; Pages -\u0026gt; Branch选择main分支，然后保存，会自动开启 https://{github用户名}.github.io 的地址，这地址也是以后访问博客的地址\n（3）回到hugo文件中，执行命令hugo -D，会生成 public 静态资源文件夹\n（4）在 public 执行以下命令上传到github仓库上，第一次上传可能需要输入账号密码\n1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main （5）上传成功后访问 https://{github用户名}.github.io，成功搭建属于自己的Hugo博客\nGithub Action自动部署 （1）Github创建一个新的仓库，用于存放Hugo的主文件\n（2）前往Setttings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens，创建一个token(classic)\n（3）token选择永不过期，并勾选 repo 和 workflow 选项\n（4）为保证安全，将生成的token，保存的仓库的变量中，前往Settings -\u0026gt; Secrets and variables -\u0026gt; Actions中设置\n（5）在hugo主文件创建一个.github/workflows/xxxx.yaml文件，将以下内容复制进去，想具体了解更多，可查看【Github Action文档】\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy （6）在hugo主文件创建.gitignore文件，来避免提交不必要的文件\n1 2 3 4 5 6 7 # 自动生成的文件 public resources .hugo_build.lock # hugo命令 hugo.exe （7）将hugo的主文件上传到仓库，上传成功后会触发Github Action，来自动部署你的静态页面\n1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main Reference https://letere-gzj.github.io/hugo-stack/p/hugo/custom-blog/ ","date":"2025-02-05T00:00:00Z","permalink":"https://loveleaves.github.io/p/hugo-blog/","title":"Hugo + Github 免费部署自己的博客"}]